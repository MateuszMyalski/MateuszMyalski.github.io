<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta title="eSDE-notes">

    <link rel="alternate" type="application/atom+xml" title="Notes collected during development, work, learning..." href="/atom.xml">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Mateusz Myalski">
    <meta name="google-site-verification" content="A8chtL3v4vPM3jRZZVlCtwpChyjii_n7C9bifQOfYzg" />
    <link rel="shortcut icon" href="https://mateuszmyalski.github.io/theme/favicon.png" type="image/x-icon">
    <link rel="icon" href="https://mateuszmyalski.github.io/theme/favicon.png" type="image/x-icon">

    <meta name="description" content="Notes collected during development, work, learning..." />

    <link rel="stylesheet" type="text/css" href="https://mateuszmyalski.github.io/theme/css/style.css" />

</head>

<body>
    <header>
        <hgroup>
            <h1>
                <a href="https://mateuszmyalski.github.io/index.html">eSDE-notes</a>
            </h1>
            <p>Notes collected during development, work, learning...</p>
        </hgroup>

        <nav>
            <li>
                <a href="https://mateuszmyalski.github.io/pages/compendium.html">Compendium</a>
            </li>
            <li>
                <a href="https://github.com/MateuszMyalski">GitHub</a>
            </li>
            <li>
                <a href="atom.xml">RSS</a>
            </li>
        </nav>

    </header>

    <main>

<section class="post">
    <h1>Memory Scratch Pad Protocol - Circular Buffer</h1>
<p>When working with many ICs that acts as slave you probably have seen their memory organization. Data that is responsible for hardware configuration is mapped to a certain memory addresses which you can access or modify correspondingly. By implementing well known standards such a SPI or I2C you can send: address, command and in case of write operation data to the slave device. The region of memory which is kept updated is called memory scratchpad — this memory registers are acting like a bridge between configuration bits and also conversion results.</p>
<p>When the necessity of connection between two devices comes, we have plenty of well written standards and ready freamworks. We can make our implementation of MODBUS protocol, TCP/IP or just use raw UART connection. Using simple raw bytes right from UART buffer can sound very straight forward. Unfortunately problems are arising, when we have to receive and parse many bytes in short period of time without constantly blocking whole task execution. ISRs are coming handy, but they have their limitations especially when we can't use DMA because of lack of such great peripherals or used up channels.</p>
<p>In this article I am going to describe step by step how to implement reliable communication between microcontroller and PC. Firstly we will implement circular buffer to make space for our incoming data while the processor is busy. Next, we will write implementation of simple scratchpad like protocol. After finishing the uC part, we will move to the PC section. We will try to make use of the python script language to write our master's device code.</p>
<p>To sum up everything we will divide our finish line into few steps:
- circular buffer library - this will let us to give our uC some time to process infromation,
- scratch Pad protocole library and implementation for uC,
- python class to establish reliable connection.</p>
<h1>Circular buffer</h1>
<p>On the Internet we can find many code snippets that are ready to use. We will try to build our own version which will be ready for fast and simple reuse. Firstly we should know how our data structure should behave. </p>
<p>Basically it is a fixed size memory region (array) which is able to round around the data if the incoming bytes meet the end of the array, and can perform read/write operations simuntaniusly. Circular buffers have two pointers:
    - pointer <strong>one</strong> (head) is pointing to the region of memory where new data can be stored,
    - pointer <strong>two</strong> (tail) is pointing to the region of memory from where next data should be read.
The circular buffer is full when the next memory address of __ head__ will be the same memory address as __ tail__ is pointing to.
The circular buffer is empty when the <strong>tail</strong> and the <strong>head</strong> is pointing the same memory address.
Two pointers gives this data structer ability to read and write "parallel".</p>
<p><img alt="Circular Buffer" src="images/memory_scratch_pad_protocole/circular_buffer.jpg"></p>
<p>With this knowladge we can create simple structure for our circular buffer. Shall we create "circular_buffer.c" with:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;circular_buffer.h&quot;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">GPL_circular_buffer_t</span><span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w">  </span><span class="n">bufferSize</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w">  </span><span class="n">readIndex</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w">  </span><span class="n">writeIndex</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">     </span><span class="n">full</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w">    </span><span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">};</span><span class="w"> </span>
</code></pre></div>

<p>While creating our library we will try to protect our struct from direct access by simple trick - declerate our typedef in "circular_buffer.h":</p>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">circular_buffer</span><span class="p">;</span>
</code></pre></div>

<p>We will be obligated to dereference the void pointer to our real struct so we can access the data without problems:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">));</span>
</code></pre></div>

<p>User can initialize the circular buffer using create function:</p>
<div class="highlight"><pre><span></span><code><span class="n">GPL_circular_buffer_t</span><span class="w"> </span><span class="o">*</span><span class="nf">circular_buffer_create</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">));</span>
<span class="w">    </span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">));</span>
<span class="w">    </span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">bufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">readIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">writeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">circular_buffer</span><span class="p">)</span><span class="n">handler</span><span class="p">;</span>
<span class="p">}</span><span class="w">  </span>
</code></pre></div>

<p>Do not forget that what we malloc/calloc we have to free up. The deinicializer seems pretty straight forward. We have made <em>malloc</em> for the structure and <em>calloc</em> for the buffer itself:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">circular_buffer_destroy</span><span class="p">(</span><span class="n">circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">){</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">__handler</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Small handy functions for easier code readability:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">circular_buffer_full</span><span class="p">(</span><span class="n">circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">){</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">circular_buffer_reset</span><span class="p">(</span><span class="n">circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">){</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">    </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">readIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">writeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span><span class="w"> </span><span class="nf">circular_buffer_capacity</span><span class="p">(</span><span class="n">circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">){</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">bufferSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">circular_buffer_empty</span><span class="p">(</span><span class="n">circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">){</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">readIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">writeIndex</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Now we need to take care of the logic. Firstly we will allow the user to push new byte:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">circular_buffer_write</span><span class="p">(</span><span class="n">circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">data</span><span class="p">){</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">circular_buffer_full</span><span class="p">(</span><span class="n">handler</span><span class="p">)){</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">writeIndex</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">writeIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">writeIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">bufferSize</span><span class="p">;</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">writeIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">readIndex</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="k">else</span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>

<p>We have used small little trick with modulo operator to be sure that we won't exceed the allocated memory region. In example, we have only 5 element array, but the counter is constantly incrementing, we would like to overwrite the data so:</p>
<div class="highlight"><pre><span></span><code><span class="nv">char</span><span class="w"> </span><span class="nv">array</span>[<span class="mi">5</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span>{<span class="w"> </span><span class="mi">0</span><span class="w"> </span>}<span class="c1">;</span>
<span class="w">    </span><span class="k">for</span><span class="ss">(</span><span class="nv">int</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">; i &lt; 10; ++i)</span>
<span class="w">        </span><span class="nv">array</span>[<span class="nv">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span>]<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">i</span><span class="c1">;</span>

<span class="w">    </span><span class="nv">printf</span><span class="ss">(</span><span class="s2">&quot;%c&quot;</span>,<span class="w"> </span><span class="nv">array</span>[<span class="mi">0</span>]<span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">printf</span><span class="ss">(</span><span class="s2">&quot;%c&quot;</span>,<span class="w"> </span><span class="nv">array</span>[<span class="mi">1</span>]<span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">printf</span><span class="ss">(</span><span class="s2">&quot;%c&quot;</span>,<span class="w"> </span><span class="nv">array</span>[<span class="mi">2</span>]<span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">printf</span><span class="ss">(</span><span class="s2">&quot;%c&quot;</span>,<span class="w"> </span><span class="nv">array</span>[<span class="mi">3</span>]<span class="ss">)</span><span class="c1">;</span>
<span class="w">    </span><span class="nv">printf</span><span class="ss">(</span><span class="s2">&quot;%c&quot;</span>,<span class="w"> </span><span class="nv">array</span>[<span class="mi">4</span>]<span class="ss">)</span><span class="c1">;</span>
</code></pre></div>

<p>the output is going to be:</p>
<div class="highlight"><pre><span></span><code>&gt;<span class="w"> </span>fghij
</code></pre></div>

<p>because the output of <code>0 % 5 is 0</code> <code>3 % 5 is 3</code> <code>5 % 5 is 0</code> <code>6 % 5 is 1</code> etc.</p>
<p>To read character we should make exactly the same thing but with read pointer instead of write pointer:</p>
<div class="highlight"><pre><span></span><code><span class="kt">char</span><span class="w"> </span><span class="nf">circular_buffer_read</span><span class="p">(</span><span class="n">circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">){</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">__circular_buffer</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">                                                </span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">circular_buffer_empty</span><span class="p">(</span><span class="n">handler</span><span class="p">)){</span>
<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">readIndex</span><span class="p">];</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">readIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">readIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">bufferSize</span><span class="p">;</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Now we can go forward to create our scratch pad protocole implementation. </p>
<p>Below you can find ready files with circular buffer library:</p>
<p><a href="https://github.com/MateuszMyalski/GPL">GPL_library</a></p>

    <section class="meta">
        <div class="title_block">
            <span class="title_label">
                Title:
            </span>
            <span class="title">
                Memory Scratch Pad Protocol - Circular Buffer
            </span>
        </div>
        <div class="date_block">
            <span class="date_label">
                Posted on:
            </span>
            <span class="date">
                <time datetime="2020-10-09T00:00:00+02:00">09/10/2020
            </span>
        </div>
        <div class="print">
            <a href="javascript:if(window.print)window.print()">🖨️ Print</a>
        </div>
    </section>
</section>

</section>

    </main>

    <footer>
        Made with<span id="heart">&#9829;</span>
    </footer>
</body>

</html>
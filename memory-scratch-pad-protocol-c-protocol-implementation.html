<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta title="Tech-Notes">

    <link rel="alternate" type="application/atom+xml" title="Notes collected during development, work, learning..." href="/atom.xml">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Mateusz Myalski">
    <link rel="shortcut icon" href="https://mateuszmyalki.github.io/theme/favicon.png" type="image/x-icon">
    <link rel="icon" href="https://mateuszmyalki.github.io/theme/favicon.png" type="image/x-icon">

    <meta name="description" content="Notes collected during development, work, learning..." />

    <link rel="stylesheet" type="text/css" href="https://mateuszmyalki.github.io/theme/css/style.css" />

</head>

<body>
    <header>
        <hgroup>
            <h1>
                <a href="https://mateuszmyalki.github.io/index.html">Tech-Notes</a>
            </h1>
            <p>Notes collected during development, work, learning...</p>
        </hgroup>

        <nav>
            <li>
                <a href="https://mateuszmyalki.github.io/pages/compendium.html">Compendium</a>
            </li>
            <li>
                <a href="https://github.com/MateuszMyalski">GitHub</a>
            </li>
            <li>
                <a href="atom.xml">RSS</a>
            </li>
        </nav>

    </header>

    <main>

<section class="post">
    <h1>Memory Scratch Pad Protocol - C Protocol Implementation</h1>
<p>In the previous chapter we have created implementation of circular buffer. Let's put this aside now and think, how we will parse our incoming messages. We have decided that every byte will mean something, and we also stated that bytes will not be translated into any ASCII character. What will happen after our program runs?</p>
<p>Our protocol will wait for one or two bytes. The amount of bytes that we need to receive is going to depend on what kind of action is going to be performed on the registers. Always, the first received byte is going to be the index of the register, second byte is going to be an eventual data that we want to store in the register. But how we can easily recognize when we want to perform write operation? There are many solutions to solve this problem. I am going to describe my idea.</p>
<p>Imagine 32 registers, every register is 8 bits long (uint8_t) we can index them from 0 to 31, so basically our memory scratch pad is a standard 'array' of 'chars'. If we know the size of the scratch pad, we can easily add the scratch pad size to the first byte. This is way of identifying write/read operation if we are performing read operation, we are going to send number from 0 to 31, in case of write operation we are going to offset the register index + scratchpad size to the first byte. Our algorithm will check however the first received byte is greater than our scratch pad size or not.</p>
<p>We have made our formal decisions, we should create a graph that will perhaps clarify a bit what we would like to achieve. </p>
<p><img alt="Circular Buffer" src="images/memory_scratch_pad_protocole/scratchpad_algorithm.png">
<img alt="Circular Buffer" src="images/memory_scratch_pad_protocole/scratchpad_example.png"></p>
<p>We would like to create a hideable instance of the protocol implementation to create easy to use library. Functions related with parsing should be called in <strong>main</strong> loop or <strong>on interrupt</strong> from counter rather than in ISR which is generated after received character. The idea demonstration can be showed with rather simple pseudo-code:</p>
<div class="highlight"><pre><span></span><code><span class="n">INIT</span><span class="o">:</span>
<span class="w">    </span><span class="n">initialize_rx_circular_buffer</span>
<span class="w">    </span><span class="n">initialize_communication</span>
<span class="w">    </span><span class="n">initialize_rx_isr</span>

<span class="n">MAIN_LOOP</span><span class="o">:</span>
<span class="w">    </span><span class="o">...</span>
<span class="w">    </span><span class="n">IF</span><span class="w"> </span><span class="o">!</span><span class="n">rx_circular_buffer_empty</span><span class="o">:</span>
<span class="w">        </span><span class="n">read_circular_buffer</span>
<span class="w">        </span><span class="n">parse_data</span>
<span class="w">        </span><span class="n">IF</span><span class="w"> </span><span class="n">read_command</span><span class="o">:</span>
<span class="w">            </span><span class="n">send_data</span>
<span class="w">    </span><span class="o">...</span>

<span class="n">RX_ISR</span><span class="o">:</span>
<span class="w">    </span><span class="n">push_rx_byte_to_rx_circular_buffer</span>
</code></pre></div>

<p>... or we can initialize another ISR from counter, and parse incoming data without blocking the main program:</p>
<div class="highlight"><pre><span></span><code><span class="n">INIT</span><span class="o">:</span>
<span class="w">    </span><span class="n">initialize_rx_circular_buffer</span>
<span class="w">    </span><span class="n">initialize_tx_circular_buffer</span>
<span class="w">    </span><span class="n">initialize_communication</span>
<span class="w">    </span><span class="n">initialize_rx_isr</span>
<span class="w">    </span><span class="n">initialize_counter_isr</span>

<span class="n">MAIN_LOOP</span><span class="o">:</span>
<span class="w">    </span><span class="o">...</span>

<span class="n">RX_ISR</span><span class="o">:</span>
<span class="w">    </span><span class="n">push_rx_byte_to_rx_circular_buffer</span>

<span class="n">COUNTER_ISR</span><span class="o">:</span>
<span class="w">    </span><span class="n">IF</span><span class="w"> </span><span class="o">!</span><span class="n">tx_circular_buffer_empty</span><span class="o">:</span>
<span class="w">        </span><span class="n">send_data</span>
<span class="w">        </span><span class="k">return</span>

<span class="w">    </span><span class="n">IF</span><span class="w"> </span><span class="o">!</span><span class="n">rx_circular_buffer_empty</span><span class="o">:</span>
<span class="w">            </span><span class="n">read_circular_buffer</span>
<span class="w">            </span><span class="n">parse_data</span>
<span class="w">            </span><span class="n">IF</span><span class="w"> </span><span class="n">read_command</span><span class="o">:</span>
<span class="w">                </span><span class="n">push_bytes_to_tx_circular_buffer</span>
</code></pre></div>

<p>Notice, that in the <strong>counter_isr</strong> the first thing we have to make is check whether the previous question (read operation) was answered before parsing another query.</p>
<p>Before writing the logic, we should decorate our struct and enum:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;GPL_scratch_pad_protocle.h&quot;</span>
<span class="k">enum</span><span class="w"> </span><span class="n">scratchPad_e</span><span class="w"> </span><span class="p">{</span><span class="n">IDLE</span><span class="p">,</span><span class="w"> </span><span class="n">READ</span><span class="p">,</span><span class="w"> </span><span class="n">WRITE_ADDRESS</span><span class="p">,</span><span class="w"> </span><span class="n">WRITE_VALUE</span><span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">scratchPad_e</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">scratchPad_size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">scratchPad</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>We are making the same trick with encapsulation, just insert <code>typedef void* GPL_ScratchPad_t;</code> to the <code>.h</code> file.
Looking at the algorythm and pseudocode we can create our scratchpad initializer:</p>
<div class="highlight"><pre><span></span><code><span class="n">GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="nf">GPL_ScratchPad_create</span><span class="p">(</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">scratchPad</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">scratchPad_size</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">scratchPad_size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">scratchPad</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDLE</span><span class="p">;</span>
<span class="w">    </span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">scratchPad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scratchPad</span><span class="p">;</span>
<span class="w">    </span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">scratchPad_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scratchPad_size</span><span class="p">;</span>


<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">GPL_ScratchPad_t</span><span class="w"> </span><span class="p">)</span><span class="n">handler</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Below simple functions that I recon are self describing.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">GPL_ScratchPad_reset</span><span class="p">(</span><span class="w"> </span><span class="n">GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>
<span class="w">    </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">GPL_ScratchPad_destroy</span><span class="p">(</span><span class="w"> </span><span class="n">GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="w"> </span><span class="n">__handler</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">char</span><span class="w"> </span><span class="nf">GPL_ScratchPad_read</span><span class="p">(</span><span class="w"> </span><span class="n">GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">    </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDLE</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">scratchPad</span><span class="p">[(</span><span class="kt">size_t</span><span class="p">)</span><span class="w"> </span><span class="n">address</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>

<p>Why we are creating read function, if we can directly access the data? Because we want to be sure that the state machine is resetted after read operation. This small thing will protect the programmer from accessing indexes that should be a value not an address.</p>
<p>Now, we can proceed to write the core function that will take care of word processing, we need to remember that we are going to parse the stored data byte by byte. Therefor the state of the machine needs to be tracked somehow, here we are going to use already peppered enum.</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">GPL_ScratchPad_processByte</span><span class="p">(</span><span class="w"> </span><span class="n">GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDLE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">scratchPad_size</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDLE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">scratchPad_size</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">scratchPad_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WRITE_ADDRESS</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">WRITE_ADDRESS</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">WRITE_VALUE</span><span class="p">)</span>
<span class="w">        </span><span class="n">_GPL_ScratchPad_write</span><span class="p">(</span><span class="w"> </span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">READ</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>This only initialize 1/3 of our state machine, the enigmatic function <code>_GPL_ScratchPad_write</code> will take care of the scenario, where we have to store somehow the previous byte to know to which location the user want to write incoming data.</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">_GPL_ScratchPad_write</span><span class="p">(</span><span class="w"> </span><span class="n">GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="n">__handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">__GPL_ScratchPad_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">address</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">WRITE_ADDRESS</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">scratchPad_size</span><span class="p">;</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WRITE_VALUE</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">WRITE_VALUE</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">scratchPad</span><span class="p">[(</span><span class="kt">size_t</span><span class="p">)</span><span class="w"> </span><span class="n">address</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">byte</span><span class="p">;</span>
<span class="w">        </span><span class="n">__handler</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDLE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>We are using here static variable, that will keep the content on heap - this will let us remember the previous byte (address), after we exit the function to receive the value that need to be stored in scratch pad register.
Now it is time to connect our circular buffer and the scratchpad protocol together. I don't want to get into details about how to initialize isr or how to initialize serial communication for each microcontroller. These are beyond the scope of this article. But the pseudo code should answer the question of how to implement this in your code.
I would like to divide our task into some small steps, it is great technique if you are embedding the code from the internet but you don't know where you should call the function.
- Do we want to block our main loop? - Perhaps no.
- If no, how fast we would like to parse the incoming data? - For my baudrate I think that 100Hz (every 10ms) is enough.</p>
<ol>
<li>Define how our response would look like. I will choose standard size frame with hex formatting (it will help later) - my response frame will look like this: '"0x%x:0:%x"' (first flag is for hexadecimal format of address byte, next flag is for hexadecimal value from requested address).</li>
<li>Include header file for 'scratchpad' and 'circular buffer'.</li>
<li>Initialize (globally) 'scratchpad' and 'circular buffer' handlers.</li>
<li>Prepare scratchpad array and define its size.</li>
<li>Call '_create' on each initialized handlers.</li>
<li>Reset circular buffers.</li>
<li>Initialize serial, counter ISR.</li>
<li>IN RX ISR: push received data to the dedicated circular buffer.</li>
<li>IN COUNTER ISR: Check if we need to answer for read operation by checking if tx circular buffer is empty.</li>
<li>IN COUNTER ISR: If tx buffer not empty, send byte, and exit ISR without parsing received data. (Till we won't empty out the tx buffer).</li>
<li>IN COUNTER ISR: Do we have any data to parse, if yes, read from rx circular buffer, and process the byte, if we will read, format the response from and load it to the tx buffer.</li>
</ol>
<p>Now we are ready to translate it into the code:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* STEP 2 */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;GPL_circular_buffer.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;GPL_scratch_pad_protocle.h&quot;</span>
<span class="cm">/* STEP 3 */</span>
<span class="n">GPL_ScratchPad_t</span><span class="w"> </span><span class="n">scratchPad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="n">GPL_CircularBuffer_t</span><span class="w"> </span><span class="n">RX_circularBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="n">GPL_CircularBuffer_t</span><span class="w"> </span><span class="n">TX_circularBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* STEP 4 */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">scratchPad_memory</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="cm">/* STEP 5 */</span>
<span class="w">    </span><span class="n">scratchPad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPL_ScratchPad_create</span><span class="p">(</span><span class="w"> </span><span class="n">scratchPad_memory</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="w"> </span><span class="n">scratchPad_memory</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">RX_circularBuffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">    </span><span class="n">RX_circularBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPL_CircularBuffer_create</span><span class="p">(</span><span class="w"> </span><span class="n">RX_circularBuffer_size</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">GPL_CircularBuffer_reset</span><span class="p">(</span><span class="w"> </span><span class="n">RX_circularBuffer</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">TX_circularBuffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">    </span><span class="n">TX_circularBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPL_CircularBuffer_create</span><span class="p">(</span><span class="w"> </span><span class="n">TX_circularBuffer_size</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">GPL_CircularBuffer_reset</span><span class="p">(</span><span class="w"> </span><span class="n">TX_circularBuffer</span><span class="w"> </span><span class="p">);</span>


<span class="w">    </span><span class="cm">/* STEP 7 */</span>
<span class="w">    </span><span class="n">UART_INIT</span><span class="p">;</span>
<span class="w">    </span><span class="n">COUNTER0_INIT</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">SOME_CODE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">ISR</span><span class="p">(</span><span class="n">UART_RX</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* STEP 8 */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">RX_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UART_RX_BUFFER</span><span class="p">;</span>
<span class="w">    </span><span class="n">GPL_CircularBuffer_write</span><span class="p">(</span><span class="w"> </span><span class="n">RX_circularBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">RX_byte</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ISR</span><span class="p">(</span><span class="n">COUNTER0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* STEP 9 */</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">GPL_CircularBuffer_empty</span><span class="p">(</span><span class="w"> </span><span class="n">TX_circularBuffer</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* STEP 10 */</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">TX_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPL_CircularBuffer_read</span><span class="p">(</span><span class="w"> </span><span class="n">TX_circularBuffer</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="n">USART_Transmit</span><span class="p">(</span><span class="n">TX_byte</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* STEP 11 */</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">GPL_CircularBuffer_empty</span><span class="p">(</span><span class="w"> </span><span class="n">RX_circularBuffer</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPL_CircularBuffer_read</span><span class="p">(</span><span class="w"> </span><span class="n">RX_circularBuffer</span><span class="w"> </span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">GPL_ScratchPad_processByte</span><span class="p">(</span><span class="w"> </span><span class="n">scratchPad</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">){</span>
<span class="w">            </span><span class="kt">char</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPL_ScratchPad_read</span><span class="p">(</span><span class="w"> </span><span class="n">scratchPad</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">            </span><span class="cm">/* STEP 1 */</span>
<span class="w">            </span><span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;0x%x:0x%x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">byte</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>

<span class="w">            </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span>
<span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">buffer_ptr</span><span class="p">)</span>
<span class="w">                </span><span class="n">GPL_CircularBuffer_write</span><span class="p">(</span><span class="w"> </span><span class="n">TX_circularBuffer</span><span class="p">,</span><span class="o">*</span><span class="n">buffer_ptr</span><span class="o">++</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>You can see there isn't much code that need to be inserted. There is still room for improvements, for example 'snprintf' in ISR is not a good idea, we can evaluate the date in different way, but right now it should work as intended without any extra problems. Hey, as someone has said "On my PC it works!".</p>
<p><a href="https://github.com/MateuszMyalski/GPL">GPL_library</a></p>

    <section class="meta">
        <div class="title_block">
            <span class="title_label">
                Title:
            </span>
            <span class="title">
                Memory Scratch Pad Protocol - C Protocol Implementation
            </span>
        </div>
        <div class="date_block">
            <span class="date_label">
                Posted on:
            </span>
            <span class="date">
                <time datetime="2020-10-10T00:00:00+02:00">10/10/2020
            </span>
        </div>
        <div class="print">
            <a href="javascript:if(window.print)window.print()">&#128438; Print</a>
        </div>
    </section>
</section>

</section>

    </main>

    <footer>
        Made with<span id="heart">&#9829;</span>
    </footer>
</body>

</html>
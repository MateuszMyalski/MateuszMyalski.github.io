<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta title="eSDE-notes">

    <link rel="alternate" type="application/atom+xml" title="Notes collected during development, work, learning..." href="/atom.xml">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Mateusz Myalski">
    <meta name="google-site-verification" content="A8chtL3v4vPM3jRZZVlCtwpChyjii_n7C9bifQOfYzg" />
    <link rel="shortcut icon" href="https://mateuszmyalski.github.io/theme/favicon.png" type="image/x-icon">
    <link rel="icon" href="https://mateuszmyalski.github.io/theme/favicon.png" type="image/x-icon">

    <meta name="description" content="Notes collected during development, work, learning..." />

    <link rel="stylesheet" type="text/css" href="https://mateuszmyalski.github.io/theme/css/style.css" />

</head>

<body>
    <header>
        <hgroup>
            <h1>
                <a href="https://mateuszmyalski.github.io/index.html">eSDE-notes</a>
            </h1>
            <p>Notes collected during development, work, learning...</p>
        </hgroup>

        <nav>
            <li>
                <a href="https://mateuszmyalski.github.io/pages/compendium.html">Compendium</a>
            </li>
            <li>
                <a href="https://github.com/MateuszMyalski">GitHub</a>
            </li>
            <li>
                <a href="atom.xml">RSS</a>
            </li>
        </nav>

    </header>

    <main>

<section class="post">
    <h1>H.264 Data format - Access unit and NAL unit</h1>
<p>H.264, also known as Advanced Video Coding (AVC), is one of the most widely used video compression standards in the world. Developed by the ITU-T Video Coding Experts Group and the ISO/IEC Moving Picture Experts Group, H.264 is designed to deliver high-quality video at lower bitrates, making it ideal for streaming applications.</p>
<p>This codec achieves its efficiency through a variety of techniques, including predictive coding, motion compensation, and variable block-size segmentation. H.264 organizes video data into Access Units, which are composed of Network Abstraction Layer (NAL) units. These NAL units carry the actual encoded video data along with necessary metadata, allowing for flexible and efficient video streaming.</p>
<p>Due to its adaptability and support for a wide range of resolutions and bitrates, H.264 has become the backbone of many streaming services, from video-on-demand platforms to live broadcasts. Understanding its structure and how data is encapsulated within the codec is crucial for anyone working with video streaming technologies.</p>
<h2>Access Unit</h2>
<blockquote>
<p>A set of NAL units that are consecutive in decoding order and contain exactly one primary coded picture. In addition to the primary coded picture, an access unit may also contain one or more redundant coded pictures, one auxiliary coded picture, or other NAL units not containing slices or slice data partitions of a coded picture. <strong>The decoding of an access unit always results in a decoded picture</strong></p>
</blockquote>
<p>Basing on the definition provided by the ITU-T documentation the <strong>access unit</strong> is the smallest unit of data that can be independently decoded to produce one complete video frame. Access unit encapsulates all necessary information for decoding the picture.</p>
<p>The minimal access unit must contain one primary coded picture (I frame). In addition to the I frame it is possible to send another type of data such:</p>
<ul>
<li>redundant coded picture - Coded representation of a picture or a part of a picture which does not have to contain exactly the same amount of macroblocks as primary coded picture.</li>
<li>auxiliary coded picture - A picture that can supplement the primary coded picture which can be decoded with other data not specified in the International Standard (ITU-T). The auxiliary coded picture must have the same amount of macroblocks as the primary coded picture.</li>
<li>NAL units that can contains other information used for the decoding process, and Supplemental Enhancement Information (SEI).</li>
</ul>
<p>It is important, that the access unit must always result in decoded picture. An Access Unit containing non-IDR frame must reference a previously decoded frame (usually an I-frame or another P-frame) to be properly decoded.</p>
<h3>Order of NAL units</h3>
<p><em>ITU-T 7.4.1.2.3 Order of NAL units and coded pictures and association to access units</em> chapter specifies how the NAL units supposed to be coded in order, so decoder is able to correctly interpret received data. The begging of the access unit after the last VCL NAL unit of a primary coded picture can be identified by:
- access unit delimiter NAL unit,
- sequence parameter set NAL unit,
- picture parameter set NAL unit,
- SEI NAL unit,
- NAL units with nal_unit_type in the range of 14 to 18, inclusive,
- first VCL NAL unit of a primary coded picture.</p>
<p>In case of following: SPS, PPS, Filler data, SPS extension, Prefix NAL Unit, Subset SPS or Depth parameter set, unit types are <em>not</em> present in the access unit, the order of NAL units specifies the diagram:
<img alt="ITU-T_Figure 7-1" src="images/H.264_stream_data_format_-_Access_unit_and_NAL_unit/ITU-T_Figure 7-1.png">
<center><em>ITU-T Figure 7-1 â€“ Structure of an access unit not containing any NAL units with nal_unit_type equal to 0, 7, 8, or in the range of 12 to 18, inclusive, or in the range of 20 to 31, inclusive</em></center></p>
<h2>Descriptors</h2>
<p>The descriptors are used to describe the type used in the NAL units. The descriptor contain two parts: value type and number of bits used by the type.
The number of bits are marked with number or letter:</p>
<ul>
<li><strong>n</strong> - specifies concrete <code>n</code> amount of bits depending on different variable,</li>
<li><strong>v</strong> - variable-length,</li>
<li><strong>8,4, etc.</strong> - 8, 4 or similar number of bits</li>
</ul>
<p>There are few types of descriptors specified by the <em>ITU-T chapter 7.2</em> h264 codec:</p>
<ul>
<li><code>ae(v)</code> - context-adaptive arithmetic entropy-coded syntax element</li>
<li><code>b(8)</code> - byte having any pattern of bit string</li>
<li><code>ce(v)</code> - context-adaptive variable-length entropy-coded syntax element with the left bit first</li>
<li><code>f(n)</code> - fixed-pattern bit string using n bits written (from left to right) with the left bit first</li>
<li><code>i(n)</code> - signed integer using n bits</li>
<li><code>me(v)</code> - mapped Exp-Golomb-coded syntax element with the left bit first</li>
<li><code>se(v)</code> - signed integer Exp-Golomb-coded syntax element with the left bit first</li>
<li><code>st(v)</code> - null-terminated string encoded with UTF-8 character set</li>
<li><code>te(v)</code> - truncated Exp-Golomb-coded syntax element with left bit first</li>
<li><code>u(n)</code> - unsigned integer using n bits</li>
<li><code>ue(v)</code> - unsigned integer Exp-Golomb-coded syntax element with the left bit first.
The descriptors mentions couple of important terms, such as: context-adaptive, entropy-coded, fixed-pattern, Exp-Golomb-coded. Each descriptor has it's own way of decoding described by the <em>ITU-T chapter 9.2</em>.</li>
</ul>
<p><strong>context-adaptive entropy-coded</strong> - In the entropy-coded standard CABAC parsing process the binary numbers are treated differently based on the previous context parameters. The full process of decoding is explained in <em>ITU-T chapter 9.3</em>.</p>
<p><strong>fixed-pattern</strong> - the <code>n</code> bits are fixed and they are always the same.</p>
<p><strong>Exp-Golomb-coded</strong> - The Exponential Golomb code is a type of universal code to encode non-negative number. The h264 uses extension of the coding that allows to code negative numbers. The usage of Golomb coding instead of fixed-size of variable is to reduce the non-informative data stored in the file, or transited in case of a stream. The Golomb code splits the number by given divisor and encoded the quotient and the reminder separately.</p>
<h3>Exp-Golomb coding</h3>
<h4>Unsigned numbers encoding</h4>
<p>The Exponential Golomb code for unsigned numbers are pretty straight forward:</p>
<ol>
<li>Given number <code>x</code></li>
<li>Add one to the <code>x</code> number.</li>
<li>Write the <code>x+1</code> number in binary.</li>
<li>Count the bits written <code>n</code>.</li>
<li>Subtract one from the <code>n</code>.</li>
<li>Write <code>n-1</code> of zeroes before <code>x+1</code> number of binary representation.</li>
</ol>
<pre class="ascii center">
+------+------------+---------------+
| step |            |               |
+------+------------+---------------+
|    1 | x          |            65 |
|    2 | x+1        |            66 |
|    3 | bin(x+1)   |       1000001 |
|    4 | n          |             7 |
|    5 | n-1        |             6 |
|    6 | Exp-Golomb | 0000001000001 |
+------+------------+---------------+
</pre>

<h4>Unsigned numbers decoding</h4>
<p>When decoding the Exp-Golomb unsigned numbers we can tell that:
- The number of leading zeros <code>n</code> indicates how many bits to read next.
- The first bit after the leading zeros is always <code>1</code>, so you reconstruct the original value by reading <code>n+1</code> bits.
- Finally, subtract <code>1</code> from this binary value to get the original <code>x</code>.</p>
<ol>
<li>Given data <code>y</code></li>
<li>Count the leading zeros: Count the number of leading zeros in the encoded value <code>y</code>. Let this count be <code>n</code>.</li>
<li>Read the next <code>n+1</code> bits: After the leading zeros, read the next <code>n+1</code> bits from the encoded value. These bits represent the binary number that was encoded.</li>
<li>Construct the binary value: Combine the leading 1 (implicit in the <code>n+1</code> bits) with the next n bits. This will reconstruct the original value of x+1.</li>
<li>Subtract one: Subtract 1 from the reconstructed value to get the original number x.</li>
</ol>
<pre class="ascii center">
+------+-----------------------+-------------------+
| step |                       |                   |
+------+-----------------------+-------------------+
|    1 | y                     |     0000001000001 |
|    2 | n                     |                 6 |
|    3 | n+1 bits              |            000001 |
|    4 | x = 1&lt&ltn | (n+1 bits) | 1000001 = dec(66) |
|    5 | x -= 1                | 1000010 = dec(65) |
+------+-----------------------+-------------------+
</pre>

<h3>Extension to negative numbers</h3>
<p>The negative number (including 0) are mapped to even(<code>-2x</code>) integers, where negative numbers are mapped to odd numbers (<code>2x-1</code>).</p>
<h4>Signed numbers encoding</h4>
<p>To encode the signed Exp-Golomb numbers use the provided mapping and use standard Exp-Golomb encoding method.
0. Given non-positive (x&lt;=0) number <code>x</code>
1. Map non-positive number to positive using <code>m=-2x</code>.
2. Use Exp-Golomb encoding process for unsigned numbers.</p>
<h4>Signed numbers decoding</h4>
<ol>
<li>Given data <code>y</code></li>
<li>Proceed with decoding Exp-Golomb process for unsigned numbers.</li>
<li>Map to the non-positive number by using <code>y = -(x/2)</code></li>
</ol>
</pre>
<h2>NAL Unit</h2>
<p>The NAL unit encapsulates Raw Byte Sequence Payload (RBSP) and allows decoder to identify start of the next NAL unit. The NAL unit consist <code>data type</code> field used for identification of the payload type that is transported.</p>
<p>The ITU-T specifies the NUL Unit as follows:</p>
<blockquote>
<p>A syntax structure containing an indication of the <strong>type of data</strong> to follow and <strong>bytes containing that data</strong> in the form of an RBSP interspersed as necessary with emulation prevention bytes.</p>
</blockquote>
<p><img alt="ITU-T 7.3.1. NAL unit syntax" src="images/H.264_stream_data_format_-_Access_unit_and_NAL_unit/ITU-T_7.3.1.png">
<center><em>ITU-T 7.3.1. NAL unit syntax</em></center></p>
<p>The NAL unit structure is part of an Access Unit and together with other NAL units allows to decode the picture. NAL units types can be divided into:</p>
<ul>
<li>VCL types - a NAL units that consist data of the picture macroblocks,</li>
<li>non-VCL types - a NAL units that does not consist any macroblock's data, but stores parameters used during decoding process.
The ITU-T in Table 7-1 specifies 24 types (22 specified, 2 reserved) of the NAL units and 8 unspecified types. The most important ones are:</li>
<li>type 1 - Coded slice of a non-IDR picture (VCL)</li>
<li>type 5 - Coded slice of an IDR picture - (VCL)</li>
<li>type 7 - Sequence parameter set (non-VCL)</li>
<li>type 8 - Picture parameter set (non-VCL)</li>
<li>type 9 - Access unit delimiter (non-VCL)</li>
</ul>
<p><img alt="ITU-T Table 7-1 â€“ NAL unit type codes, syntax element categories, and NAL unit type classes" src="images/H.264_stream_data_format_-_Access_unit_and_NAL_unit/ITU-T_Table_7-1.png">
<center><em>ITU-T Table 7-1 â€“ NAL unit type codes, syntax element categories, and NAL unit type classes</em></center></p>
<p>To understand better the overall H264 byte stream structure, we should at least know what those mentioned important types are carrying.</p>
<p>The VCL type of the NAL units can use partitioning mechanism to split the picture into three color groups. To simplify things we will focus only on VCL slices that are not partitioned.</p>
<p><strong>Coded slice of a non-IDR picture</strong></p>
<p>NAL unit consist slice that carries macroblocks of non-IDR picture frame.</p>
<p><img alt="ITU-T 7.3.2.8 Sequence parameter set RBSP syntax" src="images/H.264_stream_data_format_-_Access_unit_and_NAL_unit/ITU-T_7.3.2.8.png">
<center><em>ITU-T 7.3.2.8 Sequence parameter set RBSP syntax</em></center></p>
<p><strong>Coded slice of an IDR picture</strong></p>
<p>NAL unit consist slice that carries macroblocks of IDR picture frame.
The RBSP structure of this type of NAL unit is exactly the same as for the non-IDR slice type.</p>
<p><strong>Sequence parameter set</strong></p>
<p>Carries information used decoding the picture slices. Consist parameters used for decoding sequence of the slices. The set of parameters is usually send at the beginning of the video start and are stored on the decoder side to relate to them during decoding.</p>
<p><img alt="ITU-T 7.3.2.1 Sequence parameter set RBSP syntax" src="images/H.264_stream_data_format_-_Access_unit_and_NAL_unit/ITU-T_7.3.2.1.png">
<center><em>ITU-T 7.3.2.1 Sequence parameter set RBSP syntax</em></center></p>
<p><img alt="ITU-T 7.3.1.1 Sequence parameter set data syntax" src="images/H.264_stream_data_format_-_Access_unit_and_NAL_unit/ITU-T_7.3.1.1.png">
<center><em>ITU-T 7.3.1.1 Sequence parameter set data syntax</em></center></p>
<p><strong>Picture parameter set</strong></p>
<p>Parameters that are applied only to certain picture within the slice. They relates to the sequence parameter set that is have been sent previously. Those parameters are also send before the video start for the decoder for relation in future decoding process.</p>
<p><img alt="ITU-T 7.3.2.2 Picture parameter set RBSP syntax" src="images/H.264_stream_data_format_-_Access_unit_and_NAL_unit/ITU-T_7.3.2.2.png">
<center><em>ITU-T 7.3.2.2 Picture parameter set RBSP syntax</em></center></p>
<p><strong>Access unit delimiter</strong></p>
<p>One of few units that specifies the beginning of the access unit in case no other NAL units that specifies the start of access unit is used (relate to "Order of NAL units" chapter).</p>
<p><img alt="ITU-T 7.3.2.4 Access unit delimiter RBSP syntax" src="images/H.264_stream_data_format_-_Access_unit_and_NAL_unit/ITU-T_7.3.2.4.png">
<center><em>ITU-T 7.3.2.4 Access unit delimiter RBSP syntax</em></center></p>
<h2>The chained structure of NAL units</h2>
<p>By having laid out all major parts of the packets used for the H.264 stream composition, we can collect all dots into final diagram that will show how certain structures corresponds to each other.</p>
<p>Initially, the SPS NAL Units (NALu) are sent, followed by the PPS NALu, which are related to the previously sent SPS NALu. The decoder stores these parameter sets in an array, eliminating the need to resend them during streaming. If an SPS or PPS NALu with the same ID is received again, it will replace the existing one in the array. Next, the first IDR frame slices are sent to initialize the reference frame. Subsequent access units can contain slices related to non-IDR frames, as long as they reference the previously sent reference image.</p>
<pre style="ascii center">

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      
                    â”‚Access Unit                              â”‚                      
                    â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚                      
                    â”‚â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”â”‚         â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”â”‚â”‚                      
                    â”‚â”‚NAL   â”‚RBSP  â”‚â”‚   ...   â”‚NAL   â”‚RBSP  â”‚â”‚â”‚                      
                    â”‚â”‚Unit  â”‚Data  â”‚â”‚         â”‚Unit  â”‚Data  â”‚â”‚â”‚                      
                    â”‚â”‚      â””â”€â”€â”€â”€â”€â”€â”˜â”‚         â”‚      â””â”€â”€â”€â”€â”€â”€â”˜â”‚â”‚                      
                    â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚                      
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      

      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  Decoded            Decoded                 
      â”‚ â”Œâ”€â”€â”€â”          â”‚                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”                
 â”Œâ”€â”€â”€â”€â–¼â”€â–¼â” â”Œâ”¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”¼â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â” â”Œâ”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â” â”Œâ”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
 â”‚NALu   â”‚ â”‚NALu   â”‚ â”‚NALu   â”‚ â”‚NALu        â”‚ â”‚NALu            â”‚ â”‚NALu            â”‚  
 â”‚SPS    â”‚ â”‚PPS    â”‚ â”‚PPS    â”‚ â”‚IDR slices  â”‚ â”‚Non-IDR slices  â”‚ â”‚Non-IDR slices  â”‚  
 â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â–²â–²â”€â”€â”˜ â””â”€â”€â”€â–²â”€â”€â”€â”˜ â””â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  
â”‚              â”‚â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚                 â”‚               â”‚ 
â”‚              â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚               â”‚ 
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚ 
â”‚                                            â”‚                  â”‚                  â”‚ 
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    Access Unit    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€ Access Unit â”€â”€â”€â”´â”€â”€ Access Unit â”€â”€â”€â”˜ 
</pre>

<h1>References</h1>
<ol>
<li><a href="https://www.itu.int/rec/T-REC-H.264-202108-I/en">ITU-T Rec. H.264 (06/2019)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Exponential-Golomb_coding">Exponential-Golomb coding</a></li>
</ol>

    <section class="meta">
        <div class="title_block">
            <span class="title_label">
                Title:
            </span>
            <span class="title">
                H.264 Data format - Access unit and NAL unit
            </span>
        </div>
        <div class="date_block">
            <span class="date_label">
                Posted on:
            </span>
            <span class="date">
                <time datetime="2024-08-14T00:00:00+02:00">14/08/2024
            </span>
        </div>
        <div class="print">
            <a href="javascript:if(window.print)window.print()">ğŸ–¨ï¸ Print</a>
        </div>
    </section>
</section>

</section>

    </main>

    <footer>
        Made with<span id="heart">&#9829;</span>
    </footer>
</body>

</html>